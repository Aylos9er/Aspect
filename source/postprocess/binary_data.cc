#include <aspect/postprocess/binary_data.h>
#include <aspect/parameters.h>
#include <deal.II/distributed/solution_transfer.h>
#include <deal.II/lac/block_vector.h>

#ifdef DEAL_II_WITH_ZLIB
#  include <zlib.h>
#endif

namespace aspect
{
  namespace Postprocess
  {
    template <int dim>
    BinaryData<dim>::BinaryData()
    {}

    template <int dim>
    BinaryData<dim>::~BinaryData()
    {}

    template <int dim>
    void BinaryData<dim>::initialize()
    {
      my_id = Utilities::MPI::this_mpi_process(this->get_mpi_communicator());
      this->update_time();
    }

    template< int dim>
    void BinaryData<dim>::update_time()
    {
      attributes.time = this->get_time();
      attributes.time_step = this->get_timestep();
      attributes.old_time_step = this->get_old_timestep();
      attributes.timestep_number = this->get_timestep_number();
    }

    template <int dim>
    std::pair<std::string, std::string> BinaryData<dim>::execute(TableHandler &statistics)
    {
      AssertThrow(this->get_parameters().nonlinear_solver != aspect::Parameters<dim>::NonlinearSolver::iterated_Stokes &&
                          this->get_parameters().nonlinear_solver != aspect::Parameters<dim>::NonlinearSolver::iterated_IMPES,
                  ExcMessage(std::string("Binary data postprocessor is not supported for nonlinear solver type iterated Stokes or iterated IMPES")));

      if (my_id == 0)
        {
          this->update_time();

          std::ofstream ofs(this->get_output_directory() + "fields-" +
                            Utilities::int_to_string(this->get_timestep_number(), 5) + ".bin");
          boost::archive::binary_oarchive oa(ofs);
          oa << attributes;
          ofs.close();
        }

      std::string file_name = this->get_output_directory() + "/" + filename_prefix + Utilities::int_to_string(this->get_timestep_number(), 5) + ".mesh";
      parallel::distributed::SolutionTransfer<dim, LinearAlgebra::BlockVector> sol_trans(this->get_dof_handler());
      sol_trans.prepare_serialization (this->get_solution());
      this->get_triangulation().save(file_name.c_str());

      statistics.add_value("Binary output file name", file_name);

      return std::make_pair("Writing binary output to: ", file_name);
    }

    template <int dim>
    void
    BinaryData<dim>::declare_parameters(ParameterHandler &prm)
    {
      prm.enter_subsection("Postprocess");
      {
        prm.enter_subsection("Binary data");
        {
          prm.declare_entry("Binary data file name", "solution-",
                            Patterns::FileName(),
                            "A file name prefix that will be appended to each file that is generated by the "
                            "binary output postprocessor.");
        }
        prm.leave_subsection();
      }
      prm.leave_subsection();
    }

    template <int dim>
    void
    BinaryData<dim>::parse_parameters(ParameterHandler &prm)
    {
      prm.enter_subsection("Postprocess");
      {
        prm.enter_subsection("Binary data");
        {
          filename_prefix = prm.get("Binary data file name");
        }
        prm.leave_subsection();
      }
      prm.leave_subsection();
    }
  }
}


namespace aspect
{
  namespace Postprocess
  {
    ASPECT_REGISTER_POSTPROCESSOR(BinaryData,
                                  "binary data",
                                  "A Postprocessor that output the velocity solution data per timestep.")
  }
}



