#include <aspect/material_model/melt_interface.h>
#include <aspect/compositional_initial_conditions/interface.h>
#include <aspect/geometry_model/box.h>
#include <aspect/simulator_access.h>
#include <aspect/global.h>

#include <deal.II/dofs/dof_tools.h>
#include <deal.II/dofs/dof_handler.h>
#include <deal.II/numerics/data_out.h>
#include <deal.II/base/quadrature_lib.h>
#include <deal.II/base/function_lib.h>
#include <deal.II/numerics/error_estimator.h>
#include <deal.II/numerics/vector_tools.h>
#include <deal.II/base/table.h>
#include <deal.II/base/table_indices.h>
#include <deal.II/base/std_cxx1x/array.h>


namespace aspect
{
  /**
   * This is the "Shear bands" benchmark defined in the following paper:
   * @code
   *  @Article{DMGT11,
   *    author =       {R. F. Katz and M. Spiegelman and B. Holtzman},
   *    title =        {The dynamics of melt and shear localization in
   *                    partially molten aggregates},
   *    journal =      {Nature},
   *    year =         2006,
   *    volume =       442,
   *    pages =        {676-679}
   * @endcode
   *
   * Magmatic shear bands are generated by a comination of porosity- and
   * strain-rate dependent viscosity in a simple shear regime; and the
   * angle of the shear bands is measured.
   *
   */
  namespace ShearBands
  {
    using namespace dealii;


    /**
     * @note This benchmark only talks about the flow field, not about a
     * temperature field. All quantities related to the temperature are
     * therefore set to zero in the implementation of this class.
     *
     * @ingroup MaterialModels
     */
    template <int dim>
    class ShearBandsMaterial : public MaterialModel::MeltInterface<dim>,
                               public ::aspect::SimulatorAccess<dim>
    {
      public:
      virtual bool
      viscosity_depends_on (const MaterialModel::NonlinearDependence::Dependence dependence) const
      {
        if ((dependence & MaterialModel::NonlinearDependence::strain_rate) != MaterialModel::NonlinearDependence::none)
          return true;
        else if ((dependence & MaterialModel::NonlinearDependence::compositional_fields) != MaterialModel::NonlinearDependence::none)
          return true;
        else
          return false;
      }

      virtual bool
      density_depends_on (const MaterialModel::NonlinearDependence::Dependence dependence) const
      {
        return false;
      }


      virtual bool
      compressibility_depends_on (const MaterialModel::NonlinearDependence::Dependence dependence) const
      {
        return false;
      }


      virtual bool
      specific_heat_depends_on (const MaterialModel::NonlinearDependence::Dependence dependence) const
      {
        return false;
      }


      virtual bool
      thermal_conductivity_depends_on (const MaterialModel::NonlinearDependence::Dependence dependence) const
      {
        return false;
      }

      virtual bool is_compressible () const
      {
        return false;
      }

      virtual double reference_viscosity () const
      {
        return eta_0;
      }

      virtual double reference_density () const
      {
        return reference_rho_s;
      }


      double
      get_background_porosity () const;

      /**
       * Declare the parameters this class takes through input files.
       */
      static
      void
      declare_parameters (ParameterHandler &prm);

      /**
       * Read the parameters this class declares from the parameter file.
       */
      virtual
      void
      parse_parameters (ParameterHandler &prm);


      virtual void evaluate(const typename MaterialModel::Interface<dim>::MaterialModelInputs &in,
                            typename MaterialModel::Interface<dim>::MaterialModelOutputs &out) const
      {
        const unsigned int porosity_idx = this->introspection().compositional_index_for_name("porosity");
        const double strain_rate_dependence = (1.0 - dislocation_creep_exponent) / dislocation_creep_exponent;

        for (unsigned int i=0;i<in.position.size();++i)
          {
            double porosity = std::max(in.composition[i][porosity_idx],1e-4);
            out.viscosities[i] = eta_0 * std::exp(alpha*(porosity - background_porosity));
	    if (in.strain_rate.size())
	      {
		const SymmetricTensor<2,dim> shear_strain_rate = in.strain_rate[i]
								 - 1./dim * trace(in.strain_rate[i]) * unit_symmetric_tensor<dim>();
		const double second_strain_rate_invariant = std::sqrt(std::abs(second_invariant(shear_strain_rate)));
		
		if(std::abs(second_strain_rate_invariant) > 1e-30)
		  out.viscosities[i] *= std::pow(second_strain_rate_invariant,strain_rate_dependence);
	      }
	    

            out.densities[i] = reference_rho_s;
            out.thermal_expansion_coefficients[i] = 0.0;
            out.specific_heat[i] = 1.0;
            out.thermal_conductivities[i] = 0.0;
            out.compressibilities[i] = 0.0;
            for (unsigned int c=0;c<in.composition[i].size();++c)
              out.reaction_terms[i][c] = 0.0;
          }
      }

      virtual void evaluate_with_melt(const typename MaterialModel::MeltInterface<dim>::MaterialModelInputs &in,
                                      typename MaterialModel::MeltInterface<dim>::MaterialModelOutputs &out) const
      {
        evaluate(in, out);
        const unsigned int porosity_idx = this->introspection().compositional_index_for_name("porosity");

        for (unsigned int i=0;i<in.position.size();++i)
          {
            double porosity = std::max(in.composition[i][porosity_idx],1e-4);

            out.compaction_viscosities[i] = xi_0;
            out.fluid_viscosities[i]= eta_f;
            out.permeabilities[i]= reference_permeability * std::pow(porosity,3);
            out.fluid_densities[i]= reference_rho_f;
            out.fluid_compressibilities[i] = 0.0;
          }

      }

      private:
        double reference_rho_s;
        double reference_rho_f;
        double eta_0;
        double xi_0;
        double eta_f;
        double reference_permeability;
        double dislocation_creep_exponent;
        double alpha;
        double background_porosity;
    };

    template <int dim>
    double
    ShearBandsMaterial<dim>::get_background_porosity () const
    {
      return background_porosity;
    }


    template <int dim>
    void
    ShearBandsMaterial<dim>::declare_parameters (ParameterHandler &prm)
    {
      prm.enter_subsection("Material model");
      {
        prm.enter_subsection("Shear bands material");
        {
          prm.declare_entry ("Reference solid density", "3000",
              Patterns::Double (0),
              "Reference density of the solid $\\rho_{s,0}$. Units: $kg/m^3$.");
          prm.declare_entry ("Reference melt density", "3000",
              Patterns::Double (0),
              "Reference density of the melt/fluid$\\rho_{f,0}$. Units: $kg/m^3$.");
          prm.declare_entry ("Reference shear viscosity", "1.41176e7",
              Patterns::Double (0),
              "The value of the constant viscosity $\\eta_0$ of the solid matrix. "
              "Units: $Pa s$.");
          prm.declare_entry ("Reference compaction viscosity", "1.41176e8",
              Patterns::Double (0),
              "The value of the constant volumetric viscosity $\\xi_0$ of the solid matrix. "
              "Units: $Pa s$.");
          prm.declare_entry ("Reference melt viscosity", "100.0",
              Patterns::Double (0),
              "The value of the constant melt viscosity $\\eta_f$. Units: $Pa s$.");
          prm.declare_entry ("Reference permeability", "5e-9",
              Patterns::Double(),
              "Reference permeability of the solid host rock."
              "Units: $m^2$.");
          prm.declare_entry ("Dislocation creep exponent", "6.0",
              Patterns::Double(0),
              "Power-law exponent $n_{dis}$ for dislocation creep. "
              "Units: none.");
          prm.declare_entry ("Porosity exponent", "-27.0",
              Patterns::Double(),
              "Exponent $\alpha$ for the exponential porosity-dependence "
              "of the viscosity. "
              "Units: none.");
          prm.declare_entry ("Background porosity", "0.05",
              Patterns::Double (0),
              "Background porosity used in the viscosity law. Units: none.");
        }
        prm.leave_subsection();
      }
      prm.leave_subsection();
    }



    template <int dim>
    void
    ShearBandsMaterial<dim>::parse_parameters (ParameterHandler &prm)
    {
      prm.enter_subsection("Material model");
      {
        prm.enter_subsection("Shear bands material");
        {
          reference_rho_s            = prm.get_double ("Reference solid density");
          reference_rho_f            = prm.get_double ("Reference melt density");
          eta_0                      = prm.get_double ("Reference shear viscosity");
          xi_0                       = prm.get_double ("Reference compaction viscosity");
          eta_f                      = prm.get_double ("Reference melt viscosity");
          reference_permeability     = prm.get_double ("Reference permeability");
          dislocation_creep_exponent = prm.get_double ("Dislocation creep exponent");
          alpha                      = prm.get_double ("Porosity exponent");
          background_porosity        = prm.get_double ("Background porosity");
        }
        prm.leave_subsection();
      }
      prm.leave_subsection();
    }

    /**
     * An initial conditions model for the solitary waves benchmark
     * that implements a background porosity plus white noise with
     * a certain amplitude.
     */
    template <int dim>
    class ShearBandsInitialCondition : public CompositionalInitialConditions::Interface<dim>,
                                       public ::aspect::SimulatorAccess<dim>
    {
      public:

      /**
       * Return the initial porosity as a function of position.
       */
      virtual
      double
      initial_composition (const Point<dim> &position, const unsigned int n_comp) const;

      static
      void
      declare_parameters (ParameterHandler &prm);

      virtual
      void
      parse_parameters (ParameterHandler &prm);

      /**
       * Initialization function.
       */
      void
      initialize ();

      private:
        double noise_amplitude;
        double background_porosity;
        std_cxx1x::array<unsigned int,dim> grid_intervals;
        Functions::InterpolatedUniformGridData<dim> *interpolate_noise;
    };



    template <int dim>
    void
    ShearBandsInitialCondition<dim>::initialize ()
    {
      if (dynamic_cast<const ShearBandsMaterial<dim> *>(&this->get_material_model()) != NULL)
        {
          const ShearBandsMaterial<dim> *
          material_model
            = dynamic_cast<const ShearBandsMaterial<dim> *>(&this->get_material_model());

          background_porosity = material_model->get_background_porosity();
        }
      else
        {
          AssertThrow(false,
                      ExcMessage("Initial condition shear bands only works with the material model shear bands."));
        }


      AssertThrow(noise_amplitude < background_porosity,
                  ExcMessage("Amplitude of the white noise must be smaller "
                      "than the background porosity."));

      Point<dim> extents;
      TableIndices<dim> size_idx;
      for (unsigned int d=0; d<dim; ++d)
    	size_idx[d] = grid_intervals[d]+1;

      Table<dim,double> white_noise;
      white_noise.TableBase<dim,double>::reinit(size_idx);
      std_cxx1x::array<std::pair<double,double>,dim> grid_extents;

      if (dynamic_cast<const GeometryModel::Box<dim> *>(&this->get_geometry_model()) != NULL)
      {
        const GeometryModel::Box<dim> *
        geometry_model
          = dynamic_cast<const GeometryModel::Box<dim> *>(&this->get_geometry_model());

        extents = geometry_model->get_extents();
      }
      else
        {
          AssertThrow(false,
                      ExcMessage("Initial condition shear bands only works with the box geometry model."));
        }

      for (unsigned int d=0; d<dim; ++d)
      {
    	grid_extents[d].first=0;
    	grid_extents[d].second=extents[d];
      }

      // use a fixed number as seed for random generator
      // this is important if we run the code on more than 1 processor
      std::srand(0);

      TableIndices<dim> idx;

      for (unsigned int i=0; i<white_noise.size()[0]; ++i)
      {
    	idx[0] = i;
        for (unsigned int j=0; j<white_noise.size()[1]; ++j)
        {
          idx[1] = j;
          white_noise(idx) = noise_amplitude * ((std::rand() % 10000) / 5000.0 - 1.0);
        }
      }

      interpolate_noise = new Functions::InterpolatedUniformGridData<dim> (grid_extents,
    		                                                              grid_intervals,
    		                                                              white_noise);
    }


    template <int dim>
    double
    ShearBandsInitialCondition<dim>::
    initial_composition (const Point<dim> &position, const unsigned int n_comp) const
    {
      return background_porosity + interpolate_noise->value(position);
    }


    template <int dim>
    void
    ShearBandsInitialCondition<dim>::declare_parameters (ParameterHandler &prm)
    {
      prm.enter_subsection("Compositional initial conditions");
      {
        prm.enter_subsection("Shear bands initial condition");
        {
          prm.declare_entry ("Noise amplitude", "0.0005",
              Patterns::Double (0),
              "Amplitude of the white noise added to the initial "
              "porosity. Units: none.");
          prm.declare_entry ("Grid intervals for noise X", "100",
              Patterns::Integer (0),
              "Grid intervals in X directions for the white noise added to "
              "the initial background porosity that will then be interpolated "
              "to the model grid. "
              "Units: none.");
          prm.declare_entry ("Grid intervals for noise Y", "25",
              Patterns::Integer (0),
              "Grid intervals in Y directions for the white noise added to "
              "the initial background porosity that will then be interpolated "
              "to the model grid. "
              "Units: none.");
        }
        prm.leave_subsection();
      }
      prm.leave_subsection();
    }



    template <int dim>
    void
    ShearBandsInitialCondition<dim>::parse_parameters (ParameterHandler &prm)
    {
      prm.enter_subsection("Compositional initial conditions");
      {
        prm.enter_subsection("Shear bands initial condition");
        {
          noise_amplitude      = prm.get_double ("Noise amplitude");
          grid_intervals[0]    = prm.get_integer ("Grid intervals for noise X");
          grid_intervals[1]    = prm.get_integer ("Grid intervals for noise Y");
        }
        prm.leave_subsection();
      }
      prm.leave_subsection();
    }



    /**
      * A postprocessor that evaluates the angle of the shear bands.
      */
    template <int dim>
    class ShearBandsPostprocessor : public Postprocess::Interface<dim>, public ::aspect::SimulatorAccess<dim>
    {
      public:
        /**
         * Generate graphical output from the current solution.
         */
        virtual
        std::pair<std::string,std::string>
        execute (TableHandler &statistics);

      private:
        double amplitude;
        double background_porosity;

    };


    template <int dim>
    std::pair<std::string,std::string>
    ShearBandsPostprocessor<dim>::execute (TableHandler &statistics)
    {
      // write output that can be used to calculate the angle of the shear bands
      const unsigned int max_lvl = this->get_triangulation().n_global_levels();
      
      std::vector< Point<3> > data;  //x, y, porosity
      
      // we want to have equidistant points in the output
      const QMidpoint<1> mp_rule;
      const QIterated<dim> quadrature_formula (mp_rule, 2);
      const unsigned int n_q_points =  quadrature_formula.size();
      
      FEValues<dim> fe_values (this->get_mapping(), this->get_fe(),  quadrature_formula,
                               update_JxW_values | update_values | update_quadrature_points);

      std::vector<double>         porosity_values (quadrature_formula.size());
      const unsigned int porosity_idx = this->introspection().compositional_index_for_name("porosity");

      typename DoFHandler<dim>::active_cell_iterator
      cell = this->get_dof_handler().begin_active(),
      endc = this->get_dof_handler().end();
      for (; cell != endc; ++cell)
        {
	  if (!cell->is_locally_owned())
	    continue;

          fe_values.reinit (cell);
          fe_values[this->introspection().extractors.compositional_fields[porosity_idx]].get_function_values (this->get_solution(), porosity_values);

          for (unsigned int q = 0; q < n_q_points; ++q)
            {
	      data.push_back(Point<3>(fe_values.quadrature_point (q) (0),
				      fe_values.quadrature_point (q) (1),
				      porosity_values[q]));
            }
        }

      unsigned int myid = Utilities::MPI::this_mpi_process(this->get_mpi_communicator());
      unsigned int nprc = Utilities::MPI::n_mpi_processes(this->get_mpi_communicator());

      std::string filename = this->get_output_directory() + "shear_bands_" +
			    Utilities::int_to_string(max_lvl) +
			    ".csv";
      
      if (myid==0)
	{
	  std::ofstream f (filename.c_str());
	  f.precision (16);
	  // write header
	  f << "x                      y                      porosity" << std::endl;
	  f << std::scientific;

	  // output my data
	  for (unsigned int i=0;i<data.size();++i)
	    f << data[i] << std::endl;

	  // receive data
	  for (unsigned int p=0;p<nprc-1;++p)
	    {
	      MPI_Status status;
	      MPI_Probe(MPI_ANY_SOURCE, 42, this->get_mpi_communicator(), &status);
	      int incoming_size = 0;	      
	      MPI_Get_count(&status, MPI_BYTE, &incoming_size);
	      int n_points = incoming_size / sizeof(Point<3>);
	      data.resize(n_points);
	      //std::cout << "I got " << n_points << " points (" << incoming_size << " bytes) from " << status.MPI_SOURCE << std::endl;
	      MPI_Recv(&data[0], incoming_size, MPI_BYTE, status.MPI_SOURCE, 42, this->get_mpi_communicator(), &status);

	      // output received data
	      for (unsigned int i=0;i<data.size();++i)
		f << data[i] << std::endl;
	    }
	  
	}
      else
	{
	  //send data
	  AssertThrow(data.size()>0, ExcInternalError());
	  //std::cout << "I am proc " << myid << " and I am sending " << data.size() << " entries (" << data.size()*sizeof(Point<3>) << " bytes)" << std::endl;
	  MPI_Send(&data[0], sizeof(Point<3>)*data.size(), MPI_BYTE, 0, 42, this->get_mpi_communicator());
	}
      

      
      return std::make_pair("writing:", filename);

    }

  }
}



// explicit instantiations
namespace aspect
{
  namespace ShearBands
  {
    ASPECT_REGISTER_MATERIAL_MODEL(ShearBandsMaterial,
                                   "shear bands material",
                                   "A material model that corresponds to the setup to"
                                   "generate magmatic shear bands described in Katz et al., "
                                   "Nature, 2006.")

    ASPECT_REGISTER_POSTPROCESSOR(ShearBandsPostprocessor,
                                  "shear bands statistics",
                                  "A postprocessor that writes output for the porosity field, "
                                  "which can be used to calculate the angle of the shear "
                                  "bands in the model. ")

   ASPECT_REGISTER_COMPOSITIONAL_INITIAL_CONDITIONS(ShearBandsInitialCondition,
                                                    "shear bands initial condition",
                                                    "Composition is set to background porosity plus "
                                                    "white noise.")
  }
}
