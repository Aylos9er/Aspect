#include <aspect/material_model/melt_interface.h>
#include <aspect/compositional_initial_conditions/interface.h>
#include <aspect/simulator_access.h>
#include <aspect/global.h>

#include <deal.II/dofs/dof_tools.h>
#include <deal.II/dofs/dof_handler.h>
#include <deal.II/numerics/data_out.h>
#include <deal.II/base/quadrature_lib.h>
#include <deal.II/base/function_lib.h>
#include <deal.II/numerics/error_estimator.h>
#include <deal.II/numerics/vector_tools.h>



namespace aspect
{
  /**
   * This is the "Shear bands" benchmark defined in the following paper:
   * @code
   *  @Article{DMGT11,
   *    author =       {R. F. Katz and M. Spiegelman and B. Holtzman},
   *    title =        {The dynamics of melt and shear localization in
   *                    partially molten aggregates},
   *    journal =      {Nature},
   *    year =         2006,
   *    volume =       442,
   *    pages =        {676-679}
   * @endcode
   *
   * Magmatic shear bands are generated by a comination of porosity- and
   * strain-rate dependent viscosity in a simple shear regime; and the
   * angle of the shear bands is measured.
   *
   */
  namespace ShearBands
  {
    using namespace dealii;


    /**
     * @note This benchmark only talks about the flow field, not about a
     * temperature field. All quantities related to the temperature are
     * therefore set to zero in the implementation of this class.
     *
     * @ingroup MaterialModels
     */
    template <int dim>
    class ShearBandsMaterial : public MaterialModel::MeltInterface<dim>,
                               public ::aspect::SimulatorAccess<dim>
    {
      public:
      virtual bool
      viscosity_depends_on (const MaterialModel::NonlinearDependence::Dependence dependence) const
      {
        if ((dependence & MaterialModel::NonlinearDependence::strain_rate) != MaterialModel::NonlinearDependence::none)
          return true;
        else if ((dependence & MaterialModel::NonlinearDependence::compositional_fields) != MaterialModel::NonlinearDependence::none)
          return true;
        else
          return false;
      }

      virtual bool
      density_depends_on (const MaterialModel::NonlinearDependence::Dependence dependence) const
      {
        return false;
      }


      virtual bool
      compressibility_depends_on (const MaterialModel::NonlinearDependence::Dependence dependence) const
      {
        return false;
      }


      virtual bool
      specific_heat_depends_on (const MaterialModel::NonlinearDependence::Dependence dependence) const
      {
        return false;
      }


      virtual bool
      thermal_conductivity_depends_on (const MaterialModel::NonlinearDependence::Dependence dependence) const
      {
        return false;
      }

      virtual bool is_compressible () const
      {
        return false;
      }

      virtual double reference_viscosity () const
      {
        return eta_0;
      }

      virtual double reference_density () const
      {
        return reference_rho_s;
      }


      double
      get_background_porosity () const;

      /**
       * Declare the parameters this class takes through input files.
       */
      static
      void
      declare_parameters (ParameterHandler &prm);

      /**
       * Read the parameters this class declares from the parameter file.
       */
      virtual
      void
      parse_parameters (ParameterHandler &prm);


      virtual void evaluate(const typename MaterialModel::Interface<dim>::MaterialModelInputs &in,
                            typename MaterialModel::Interface<dim>::MaterialModelOutputs &out) const
      {
        const unsigned int porosity_idx = this->introspection().compositional_index_for_name("porosity");
        const double strain_rate_dependence = (1.0 - dislocation_creep_exponent) / dislocation_creep_exponent;

        for (unsigned int i=0;i<in.position.size();++i)
          {
            double porosity = std::max(in.composition[i][porosity_idx],1e-4);
            const SymmetricTensor<2,dim> shear_strain_rate = in.strain_rate[i]
                                                           - 1./dim * trace(in.strain_rate[i]) * unit_symmetric_tensor<dim>();
            const double second_strain_rate_invariant = std::sqrt(std::abs(second_invariant(shear_strain_rate)));

            out.viscosities[i] = eta_0 * std::exp(alpha*(porosity - background_porosity));
            if(std::abs(second_strain_rate_invariant) > 1e-30)
              out.viscosities[i] *= std::pow(second_strain_rate_invariant,strain_rate_dependence);

            out.densities[i] = reference_rho_s;
            out.thermal_expansion_coefficients[i] = 0.0;
            out.specific_heat[i] = 1.0;
            out.thermal_conductivities[i] = 0.0;
            out.compressibilities[i] = 0.0;
          }
      }

      virtual void evaluate_with_melt(const typename MaterialModel::MeltInterface<dim>::MaterialModelInputs &in,
                                      typename MaterialModel::MeltInterface<dim>::MaterialModelOutputs &out) const
      {
        evaluate(in, out);
        const unsigned int porosity_idx = this->introspection().compositional_index_for_name("porosity");

        for (unsigned int i=0;i<in.position.size();++i)
          {
            double porosity = std::max(in.composition[i][porosity_idx],1e-4);

            out.compaction_viscosities[i] = xi_0;
            out.fluid_viscosities[i]= eta_f;
            out.permeabilities[i]= reference_permeability * std::pow(porosity,3);
            out.fluid_densities[i]= reference_rho_f;
            out.fluid_compressibilities[i] = 0.0;
          }

      }

      private:
        double reference_rho_s;
        double reference_rho_f;
        double eta_0;
        double xi_0;
        double eta_f;
        double reference_permeability;
        double dislocation_creep_exponent;
        double alpha;
        double background_porosity;
    };

    template <int dim>
    double
    ShearBandsMaterial<dim>::get_background_porosity () const
    {
      return background_porosity;
    }


    template <int dim>
    void
    ShearBandsMaterial<dim>::declare_parameters (ParameterHandler &prm)
    {
      prm.enter_subsection("Material model");
      {
        prm.enter_subsection("Shear bands material");
        {
          prm.declare_entry ("Reference solid density", "3000",
              Patterns::Double (0),
              "Reference density of the solid $\\rho_{s,0}$. Units: $kg/m^3$.");
          prm.declare_entry ("Reference melt density", "3000",
              Patterns::Double (0),
              "Reference density of the melt/fluid$\\rho_{f,0}$. Units: $kg/m^3$.");
          prm.declare_entry ("Reference shear viscosity", "1.41176e7",
              Patterns::Double (0),
              "The value of the constant viscosity $\\eta_0$ of the solid matrix. "
              "Units: $Pa s$.");
          prm.declare_entry ("Reference compaction viscosity", "1.41176e8",
              Patterns::Double (0),
              "The value of the constant volumetric viscosity $\\xi_0$ of the solid matrix. "
              "Units: $Pa s$.");
          prm.declare_entry ("Reference melt viscosity", "100.0",
              Patterns::Double (0),
              "The value of the constant melt viscosity $\\eta_f$. Units: $Pa s$.");
          prm.declare_entry ("Reference permeability", "5e-9",
              Patterns::Double(),
              "Reference permeability of the solid host rock."
              "Units: $m^2$.");
          prm.declare_entry ("Dislocation creep exponent", "6.0",
              Patterns::Double(0),
              "Power-law exponent $n_{dis}$ for dislocation creep. "
              "Units: none.");
          prm.declare_entry ("Porosity exponent", "-27.0",
              Patterns::Double(),
              "Exponent $\alpha$ for the exponential porosity-dependence "
              "of the viscosity. "
              "Units: none.");
          prm.declare_entry ("Background porosity", "0.05",
              Patterns::Double (0),
              "Background porosity used in the viscosity law. Units: none.");
        }
        prm.leave_subsection();
      }
      prm.leave_subsection();
    }



    template <int dim>
    void
    ShearBandsMaterial<dim>::parse_parameters (ParameterHandler &prm)
    {
      prm.enter_subsection("Material model");
      {
        prm.enter_subsection("Shear bands material");
        {
          reference_rho_s            = prm.get_double ("Reference solid density");
          reference_rho_f            = prm.get_double ("Reference melt density");
          eta_0                      = prm.get_double ("Reference shear viscosity");
          xi_0                       = prm.get_double ("Reference compaction viscosity");
          eta_f                      = prm.get_double ("Reference melt viscosity");
          reference_permeability     = prm.get_double ("Reference permeability");
          dislocation_creep_exponent = prm.get_double ("Dislocation creep exponent");
          alpha                      = prm.get_double ("Porosity exponent");
          background_porosity        = prm.get_double ("Background porosity");
        }
        prm.leave_subsection();
      }
      prm.leave_subsection();
    }

    /**
     * An initial conditions model for the solitary waves benchmark
     * that implements a background porosity plus white noise with
     * a certain amplitude.
     */
    template <int dim>
    class ShearBandsInitialCondition : public CompositionalInitialConditions::Interface<dim>,
                                       public ::aspect::SimulatorAccess<dim>
    {
      public:

      /**
       * Return the initial porosity as a function of position.
       */
      virtual
      double
      initial_composition (const Point<dim> &position, const unsigned int n_comp) const;

      static
      void
      declare_parameters (ParameterHandler &prm);

      virtual
      void
      parse_parameters (ParameterHandler &prm);

      /**
       * Initialization function.
       */
      void
      initialize ();

      private:
        double noise_amplitude;
        double background_porosity;
    };



    template <int dim>
    void
    ShearBandsInitialCondition<dim>::initialize ()
    {
      if (dynamic_cast<const ShearBandsMaterial<dim> *>(&this->get_material_model()) != NULL)
        {
          const ShearBandsMaterial<dim> *
          material_model
            = dynamic_cast<const ShearBandsMaterial<dim> *>(&this->get_material_model());

          background_porosity = material_model->get_background_porosity();
        }
      else
        {
          AssertThrow(false,
                      ExcMessage("Initial condition shear bands only works with the material model shear bands ."));
        }


      AssertThrow(noise_amplitude < background_porosity,
                  ExcMessage("Amplitude of the white noise must be smaller "
                      "than the background porosity."));

      std::srand(std::time(0)); // use current time as seed for random generator
    }


    template <int dim>
    double
    ShearBandsInitialCondition<dim>::
    initial_composition (const Point<dim> &position, const unsigned int n_comp) const
    {
      double noise = noise_amplitude * ((std::rand() % 10000) / 5000.0 - 1.0);
      return background_porosity + noise;
//             + 0.5 * noise_amplitude * std::sin(position[0]*1000*3.1416) * std::sin(position[1]*1000*3.1416);
    }


    template <int dim>
    void
    ShearBandsInitialCondition<dim>::declare_parameters (ParameterHandler &prm)
    {
      prm.enter_subsection("Compositional initial conditions");
      {
        prm.enter_subsection("Shear bands initial condition");
        {
          prm.declare_entry ("Noise amplitude", "0.0005",
              Patterns::Double (0),
              "Amplitude of the white noise added to the initial "
              "porosity. Units: none.");
        }
        prm.leave_subsection();
      }
      prm.leave_subsection();
    }



    template <int dim>
    void
    ShearBandsInitialCondition<dim>::parse_parameters (ParameterHandler &prm)
    {
      prm.enter_subsection("Compositional initial conditions");
      {
        prm.enter_subsection("Shear bands initial condition");
        {
          noise_amplitude      = prm.get_double ("Noise amplitude");
        }
        prm.leave_subsection();
      }
      prm.leave_subsection();
    }



    /**
      * A postprocessor that evaluates the angle of the shear bands.
      */
    template <int dim>
    class ShearBandsPostprocessor : public Postprocess::Interface<dim>, public ::aspect::SimulatorAccess<dim>
    {
      public:
        /**
         * Generate graphical output from the current solution.
         */
        virtual
        std::pair<std::string,std::string>
        execute (TableHandler &statistics);

      private:
        double amplitude;
        double background_porosity;

    };


    template <int dim>
    std::pair<std::string,std::string>
    ShearBandsPostprocessor<dim>::execute (TableHandler &statistics)
    {
      // calclulate the angle of the shear bands
      return std::make_pair (std::string(),std::string());
    }

  }
}



// explicit instantiations
namespace aspect
{
  namespace ShearBands
  {
    ASPECT_REGISTER_MATERIAL_MODEL(ShearBandsMaterial,
                                   "shear bands material",
                                   "A material model that corresponds to the setup to"
                                   "generate magmatic shear bands described in Katz et al., "
                                   "Nature, 2006.")

    ASPECT_REGISTER_POSTPROCESSOR(ShearBandsPostprocessor,
                                  "shear bands statistics",
                                  "A postprocessor that computes the angle of the generated shear bands"
                                  "using FFT as described in Katz et al., Nature, 2006.")

   ASPECT_REGISTER_COMPOSITIONAL_INITIAL_CONDITIONS(ShearBandsInitialCondition,
                                                    "shear bands initial condition",
                                                    "Composition is set to background porosity plus "
                                                    "white noise.")
  }
}
